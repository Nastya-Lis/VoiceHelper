package com.example.voicehelper

import android.app.Activity
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.speech.RecognizerIntent
import android.speech.tts.TextToSpeech
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.EditText
import android.widget.ListView
import android.widget.ProgressBar
import android.widget.SimpleAdapter
import androidx.activity.result.contract.ActivityResultContracts
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.textfield.TextInputEditText
import com.wolfram.alpha.WAEngine
import com.wolfram.alpha.WAPlainText
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.*
import kotlin.collections.HashMap

class MainActivity : AppCompatActivity() {

    lateinit var editTextView: TextInputEditText
    lateinit var listPods: ListView
    lateinit var podsAdapter:SimpleAdapter
    lateinit var progressBar: ProgressBar
    lateinit var speech: TextToSpeech
    lateinit var engine: WAEngine
    lateinit var floatingButton: FloatingActionButton

    object code{
        const val CODE_FOR_ACTIVITY = 12345
    }


    var stateTTS: Boolean = false

    val appId = "id generated by WA"

    var pods = mutableListOf<HashMap<String, String>>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initViews()
        initWAEngine()
        initTTS()
    }

    private fun initViews() {
        val toolbar = findViewById<MaterialToolbar>(R.id.customToolBar)
        setSupportActionBar(toolbar)
        progressBar = findViewById(R.id.progressbar)
        editTextView = findViewById(R.id.edit_text)


        floatingButton = findViewById(R.id.floating_button)
        floatingButton.setOnClickListener {
            val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_PROMPT, editTextView.hint)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.US)
        }

            kotlin.runCatching {
                if(stateTTS){
                    receiverIntentRequest.launch(intent)
                    //startActivityForResult(intent,code.CODE_FOR_ACTIVITY)
                }
            }.onFailure {
                    fault -> snackBarShow(fault.message ?: R.string.voice_answer.toString())
            }
        }



        editTextView.setOnEditorActionListener { _, actionId, _ ->
            if( actionId == EditorInfo.IME_ACTION_DONE){
                pods.clear()
                podsAdapter.notifyDataSetChanged()

                val question = editTextView.text.toString()
                queryWA(question)
            }
            return@setOnEditorActionListener false
        }

        listPods = findViewById(R.id.listview)
        listPods.setOnItemClickListener { _, _, index, _ ->
            if(stateTTS){
                val identifier = pods[index]["Title"]
                val question = pods[index]["Content"]
                speech.speak(question,TextToSpeech.QUEUE_FLUSH,null, identifier)
            }
        }
        podsAdapter = SimpleAdapter(this,
            pods,
            R.layout.item_in_list,
            arrayOf("Title","Content"),
            intArrayOf(R.id.title_card, R.id.content_card)
            )
        listPods.adapter = podsAdapter
    }

    private val receiverIntentRequest = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()){
        if(it.resultCode == Activity.RESULT_OK){
            it.data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)?.get(0)?.let{
                question ->
                editTextView.setText(question)
                queryWA(question)
            }
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if(requestCode == code.CODE_FOR_ACTIVITY && resultCode == Activity.RESULT_OK){
            val question = data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)?.get(0)
                editTextView.setText(question)
                queryWA(question.toString())
        }
    }


    private fun initWAEngine() {
        engine = WAEngine().apply {
            appID = appId
            addFormat("plaintext")
        }
    }


    private fun initTTS(){
        speech = TextToSpeech(this) { code ->
            if (code != TextToSpeech.SUCCESS) {
             snackBarShow("TTS is not active")
            }
            else{
                stateTTS = true
            }
        }
        speech.language = Locale.US
    }

    private fun queryWA(stringQuery: String) {
        progressBar.visibility = ProgressBar.VISIBLE
        CoroutineScope(Dispatchers.IO).launch {
            val request = engine.createQuery(stringQuery)
            runCatching {
                engine.performQuery(request)
            }
                .onSuccess { result ->
                    withContext(Dispatchers.Main) {
                        progressBar.visibility = ProgressBar.GONE
                        if (result.isError) {
                            snackBarShow(result.errorMessage)
                            return@withContext
                        }
                        if (!result.isSuccess) {
                            editTextView.error = R.string.error_query.toString()
                            snackBarShow("Do not understand")
                            return@withContext
                        }
                        for (pod in result.pods) {
                            if (pod.isError) continue
                            val content = StringBuilder()
                            for (subPod in pod.subpods) {
                                for (element in subPod.contents) {
                                    if (element is WAPlainText) {
                                        content.append(element.text)
                                    }
                                }
                            }
                            pods.add(0, HashMap<String, String>().apply {
                                put("Title", pod.title)
                                put("Content", content.toString())
                            })
                            podsAdapter.notifyDataSetChanged()
                        }
                    }
                }
                .onFailure { error ->
                    withContext(Dispatchers.Main) {
                        progressBar.visibility = ProgressBar.GONE
                        snackBarShow(error.message ?: R.string.fatal_query_error.toString())
                    }
                }
        }
    }


    private fun snackBarShow(message: String) {
        Snackbar.make(
            findViewById(androidx.appcompat.R.id.content),
            message, Snackbar.LENGTH_INDEFINITE
        ).apply {
            setAction(android.R.string.ok) {
                dismiss()
            }
            show()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.toolbar_menu, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_clear ->{
                editTextView.text?.clear()
                pods.clear()
                podsAdapter.notifyDataSetChanged()
            }
            R.id.action_stop -> {
                speech.stop()
            }
        }
        return super.onOptionsItemSelected(item)
    }

}